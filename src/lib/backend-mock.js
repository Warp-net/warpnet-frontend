/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/Warp-net,
 <github.com.mecdy@passmail.net>

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

WarpNet is provided “as is” without warranty of any kind, either expressed or implied.
Use at your own risk. The maintainers shall not be liable for any damages or data loss
resulting from the use or misuse of this software.
*/

import {
    PRIVATE_DELETE_CHAT,
    PRIVATE_DELETE_TWEET,
    PRIVATE_GET_CHAT,
    PRIVATE_GET_CHATS,
    PRIVATE_GET_MESSAGE,
    PRIVATE_GET_MESSAGES,
    PRIVATE_GET_NOTIFICATIONS,
    PRIVATE_GET_STATS,
    PRIVATE_GET_TIMELINE,
    PRIVATE_POST_LOGIN,
    PRIVATE_POST_TWEET,
    PRIVATE_POST_UPLOAD_IMAGE,
    PRIVATE_POST_USER,
    PUBLIC_DELETE_MESSAGE,
    PUBLIC_DELETE_REPLY,
    PUBLIC_GET_FOLLOWINGS,
    PUBLIC_GET_FOLLOWERS,
    PUBLIC_GET_IMAGE,
    PUBLIC_GET_REPLIES,
    PUBLIC_GET_REPLY,
    PUBLIC_GET_TWEET,
    PUBLIC_GET_TWEET_STATS,
    PUBLIC_GET_TWEETS,
    PUBLIC_GET_USER,
    PUBLIC_GET_USERS,
    PUBLIC_GET_WHOTOFOLLOW,
    PUBLIC_POST_CHAT,
    PUBLIC_POST_FOLLOW,
    PUBLIC_POST_LIKE,
    PUBLIC_POST_MESSAGE,
    PUBLIC_POST_REPLY,
    PUBLIC_POST_RETWEET,
    PUBLIC_POST_UNFOLLOW,
    PUBLIC_POST_UNLIKE,
    PUBLIC_POST_UNRETWEET
} from "@/service/service";
import {generateUUID} from "@/lib/uuid";

const mockMap = new Map();

if (process.env.NODE_ENV === 'development') {
    console.warn("⚠️ Running in standalone mode — mocking window.go ⚠️");

    window.go = {
        main: {
            App: {
                Call: (arg1) => {
                    console.debug(`[MOCK] window.go.main.App.Call(${JSON.stringify(arg1)})`);
                    const body = generateResponse(arg1);
                    console.debug(`[MOCK] window.go.main.App.Response(${JSON.stringify(body)})`);
                    return Promise.resolve({body:body});
                }
            }
        }
    };
}


function generateResponse(arg) {
    switch (arg.path) {
        case PRIVATE_POST_LOGIN:
            const uid = generateUUID()

            const owner = {
                username: arg.body.username || "Missing!",
                node_id: arg.node_id  || "None",
                user_id: uid,
                created_at: Date.now().toString(),
            }

            const u = newUser()
            u.node_id = arg.node_id  || "None"
            u.username = arg.body.username || "Missing!"

            mockMap.set("user:"+u.id, u)
            return {identity: {token: generateUUID(), owner: owner}}

        case PRIVATE_POST_TWEET:
            const tweetUid = generateUUID()
            let t = {
                id : tweetUid,
                root_id : tweetUid,
                user_id : arg.body.user_id || "",
                username : arg.body.username || "",
                text : arg.body.text || "",
                image_key : arg.body.image_key || "",
                created_at : arg.body.created_at || Date.now().toString(),
                parent_id: null,
                retweeted_by: null,
                network: "warpnet",
                moderation: {is_ok: true},
            };

            mockMap.set("tweet:"+t.id, t)

            const timelineList = mockMap.get("timeline") || [];
            timelineList.push(t)
            mockMap.set("timeline", timelineList)

            let stats = newStats(t.id)
            mockMap.set("stats:"+t.id, stats)
            return t

        case PRIVATE_POST_USER:
            let editedUser = mockMap.get("user:"+arg.body.user_id);
            if (!editedUser) return {code:404, message:"User not found"};

            Object.assign(editedUser, arg);
            mockMap.set("user:"+arg.body.user_id, editedUser)
            return editedUser

        case PUBLIC_GET_USER:
            const gotUser = mockMap.get("user:"+arg.body.user_id)
            if (!gotUser) return {code:404, message:"User not found"};
            return gotUser;
        case PUBLIC_GET_TWEET_STATS:
            const st = mockMap.get("stats:"+arg.body.tweet_id)
            if (!st) return {code:404, message:"Stats not found"};
            return st;

        case PRIVATE_GET_STATS:
            return Object.fromEntries(mockMap);

        case PUBLIC_GET_TWEET:
            const gotTweet =  mockMap.get("tweet:"+arg.body.tweet_id)
            if (!gotTweet) return {code:404, message:"Tweet not found"};
            return gotTweet;

        case PRIVATE_GET_TIMELINE :
            const timelineTweets = mockMap.get("timeline") || [];
            return {cursor: "end", user_id: arg.body.user_id, tweets: timelineTweets}

        case PUBLIC_GET_TWEETS:
            let tweetsList = []
            for (const [key, value] of mockMap) {
                if (key.startsWith("tweet:")) {
                    tweetsList.push(value)
                }
            }
            return {cursor: "end", user_id: arg.body.user_id, tweets: tweetsList}

        case PUBLIC_GET_USERS:
            let usersList = []
            for (let i = 0; i < 5; i++)  {
                const nu = newUser()
                nu.username = ""+i
                usersList.push(nu)
                mockMap.set("user:"+nu.id, nu)
            }


            for (const [key, value] of mockMap) {
                if (key.startsWith("user:")) {
                    usersList.push(value)
                }
            }
            return {cursor: "end", user_id: arg.body.user_id, users: usersList}

        case PRIVATE_POST_UPLOAD_IMAGE:
            const imageKey = "img_"+generateUUID();
            mockMap.set("image:"+imageKey, arg.body.file);
            return {key: imageKey};

        case PUBLIC_GET_IMAGE:
            const gotImg =  {image: mockMap.get("image:"+arg.body.key)};
            if (!gotImg) return {code:404, message:"Image not found"};
            return gotImg;

        case PUBLIC_GET_WHOTOFOLLOW:
            const allUsers = [];
            for (const [key, value] of mockMap) {
                if (key.startsWith("user:")) {
                    const id = key.substring("user:".length)
                    if (id === arg.body.user_id) {
                        continue
                    }
                    const followed = mockMap.get("follow:"+id)
                    if (followed) {
                        continue
                    }
                    allUsers.push(value);
                }
            }
            return {users: allUsers.slice(0, 3)};


        case PUBLIC_POST_FOLLOW:
            const followerUser = mockMap.get("user:"+arg.body.followerId)
            if (!followerUser) return {code:404, message:"User not found"};
            followerUser.followings_count++
            mockMap.set("user:"+arg.body.followerId, followerUser)

            mockMap.set("follow:"+arg.body.following, {});
            return {code: 0, message: "Accepted"};

        case PUBLIC_POST_UNFOLLOW:
            const unfollowerUser = mockMap.get("user:"+arg.body.followerId)
            if (!unfollowerUser) return {code: 0, message: "Accepted"};
            unfollowerUser.followings_count--
            mockMap.set("user:"+arg.body.followerId, unfollowerUser)

            mockMap.delete("follow:"+arg.body.following)
            return {code: 0, message: "Accepted"};

        case PUBLIC_GET_FOLLOWERS:
            let followersList = []
            for (const [key, value] of mockMap) {
                if (key.startsWith("follow:")) {
                    followersList.push(value)
                }
            }
            return {cursor: "end", followers: followersList, followingId: arg.body.user_id};
        case PUBLIC_GET_FOLLOWINGS:
            let followingsList = [] // TODO pretend they're mutual
            for (const [key, value] of mockMap) {
                if (key.startsWith("follow:")) {
                    followingsList.push(value)
                }
            }
            return {cursor: "end", followings: followingsList, followerId: arg.body.user_id};

        case PUBLIC_POST_LIKE:
            let likeStats = mockMap.get("stats:"+arg.body.tweet_id)
            likeStats.likes_count++
            mockMap.set("stats:"+arg.body.tweet_id, likeStats)
            return {count: likeStats.likes_count};

        case PUBLIC_POST_UNLIKE:
            let unlikeStats = mockMap.get("stats:"+arg.body.tweet_id)
            unlikeStats.likes_count--
            mockMap.set("stats:"+arg.body.tweet_id, unlikeStats)
            return {count: unlikeStats.likes_count};

        case PUBLIC_POST_RETWEET:
            let retweetStats = mockMap.get("stats:"+arg.body.tweet_id)
            retweetStats.retweets_count++
            mockMap.set("stats:"+arg.body.tweet_id, retweetStats)

            const retweetedTweet = mockMap.get("tweet:"+arg.body.tweet_id)
            retweetedTweet.retweeted_by = arg.body.retweeted_by
            mockMap.set("tweet:"+retweetedTweet.id, retweetedTweet)
            return retweetedTweet // TODO add to timeline and tweets

        case PUBLIC_POST_UNRETWEET:
            let unretweetStats = mockMap.get("stats:"+arg.body.tweet_id)
            unretweetStats.retweets_count--
            mockMap.set("stats:"+arg.body.tweet_id, unretweetStats)
            return {code:0, message:"Accepted"};

        case PUBLIC_POST_REPLY:
            let reply = {
                id : generateUUID(),
                root_id : arg.body.root_id,
                parent_id : arg.body.parent_id,
                text : arg.body.text || "Missing!",
                username : arg.body.username || "Missing!",
                user_id : arg.body.user_id,
                parent_user_id : arg.body.parent_user_id,
            };

            mockMap.set("reply:"+reply.id, reply);

            let replyStats = mockMap.get("stats:"+arg.body.root_id)
            replyStats.replies_count++
            mockMap.set("stats:"+arg.body.root_id, replyStats)
            return reply;

        case PUBLIC_GET_REPLIES:
            const replies = [];
            for (const [key, value] of mockMap) {
                if (key.startsWith("reply:") && value.parent_id === arg.body.parent_id && value.root_id === arg.body.root_id)
                    replies.push(value);
            }
            return {cursor: "end", replies: replies};

        case PUBLIC_GET_REPLY:
            const gotReply =  mockMap.get("reply:"+arg.body.reply_id);
            if (!gotReply) return {code:404, message:"Reply not found"};
            return gotReply;

        case PUBLIC_DELETE_REPLY:
            let deleteReplyStats = mockMap.get("stats:"+arg.body.root_id)
            deleteReplyStats.replies_count--
            mockMap.set("stats:"+arg.body.root_id, deleteReplyStats)

            mockMap.delete("reply:"+arg.body.reply_id);
            return {code:0,message:"Accepted"};

        case PRIVATE_DELETE_TWEET:
            mockMap.get("stats:"+arg.body.tweet_id) // delete from timeline
            mockMap.delete("tweet:"+arg.body.tweet_id);
            return {code:0, message:"Accepted"};

        case PUBLIC_POST_CHAT:
            const chatId = generateUUID();
            mockMap.set("chat:"+chatId, {id: chatId, messages: []});
            return {id: chatId};

        case PRIVATE_GET_CHATS:
            const chats = [];
            for (const [key, value] of mockMap) {
                if (key.startsWith("chat:")) chats.push(value);
            }
            return {chats: chats, cursor: "end", user_id: arg.body.user_id};

        case PRIVATE_GET_CHAT:
            const gotChat = mockMap.get("chat:"+arg.body.chat_id);
            if (!gotChat) return {code:404, message:"Chat not found"};
            return gotChat;

        case PRIVATE_GET_MESSAGES:
            const chat = mockMap.get("chat:"+arg.body.chat_id);
            return chat ? {messages: chat.messages} : {messages: []};

        case PUBLIC_POST_MESSAGE:
            const msgId = generateUUID();
            const message = {
                id: msgId, chat_id: arg.body.chat_id, text: arg.body.text, created_at: new Date().toISOString(),
            };
            const targetChat = mockMap.get("chat:"+arg.body.chat_id);
            if (targetChat) targetChat.messages.push(message);
            mockMap.set("message:"+msgId, message);
            return message;

        case PRIVATE_GET_MESSAGE:
            const gotMsg =  mockMap.get("message:"+arg.body.message_id);
            if (!gotMsg) return {code:404, message:"Message not found"};
            return gotMsg;

        case PUBLIC_DELETE_MESSAGE:
            mockMap.delete("message:"+arg.body.message_id);
            return {code:0,message:"Accepted"};

        case PRIVATE_DELETE_CHAT:
            mockMap.delete("chat:"+arg.body.chat_id);
            return {code:0,message:"Accepted"};

        case PRIVATE_GET_NOTIFICATIONS:
            return {notifications: []};

        default:
            return {code:0,message:"Accepted"};
    }
}

function newUser() {
    return {
        avatar_key: "", // MIME + base64
        background_image_key: "",
        bio: "",
        created_at: Date.now().toString(),
        id: generateUUID(),
        isOffline: false,
        node_id: "None",
        network: "warpnet",
        username: "Missing!",
        website: "https://warp-net.github.io/",
        moderation: {is_ok: true},
        birthdate: "",
        updated_at: "",
        followings_count: 0,
        followers_count: 0,
        latency: 0,
        tweets_count: 0,
        metadata: {},
    }
}

function newStats(id) {
    return {
        tweet_id: id,
        retweets_count: 0,
        likes_count: 0,
        replies_count: 0,
        views_count: 0,
    }
}