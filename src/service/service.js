/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/Warp-net,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

WarpNet is provided “as is” without warranty of any kind, either expressed or implied.
Use at your own risk. The maintainers shall not be liable for any damages or data loss
resulting from the use or misuse of this software.
*/

import api from '@/lib/warpnet';
import {buildQRCode} from "@/lib/qr";

const stateMap = new Map();

const defaultLimit = 20
const endCursor = "end"

export const warpnetService = {
    reset() {
        stateMap.clear()
    },

    invalidate(prefix) {
        const keysToDelete = Array.from(stateMap.keys()).filter(k => k.startsWith(prefix));
        for (const key of keysToDelete) {
            stateMap.delete(key);
        }
    },
    setQR(qrData) {
        const key = `QR`;
        stateMap.set(key, qrData)
    },

    getQR() {
        const key = `QR`;
        return stateMap.get(key) || ""
    },

    setCursor(key, cursor) {
        const cacheKey = `${key}::cursor`;
        stateMap.set(cacheKey, cursor)
    },

    getCursor(key) {
        const cacheKey = `${key}::cursor`;
        return stateMap.get(cacheKey) || ""
    },

    setOwnerProfile(owner) {
        const key = `owner`;
        stateMap.set(key, owner)
    },

    getOwnerProfile() {
        const key = `owner`;
        return stateMap.get(key)
    },

    async signInUser(form) {
        const resp = await api.loginUser(form)
        if (!resp || !resp.identity) {
            throw new Error("Login failed: no response")
        }
        if (resp.code) {
            throw new Error(resp.message)
        }

        if (!resp.identity) {
            throw new Error("Login failed: no identity")
        }

        const qrData = JSON.stringify(resp);
        resp.identity.token = null // for security reasons

        if (!resp.identity.owner) {
            console.error("Login failed: owner identity not received")
            return;
        }

        const ownerProfile = await api.getProfile(
            {ownerNodeId: resp.identity.owner.node_id, userId: resp.identity.owner.user_id},
            )

        warpnetService.setOwnerProfile(ownerProfile)

        const qrCode = await buildQRCode(qrData)
        warpnetService.setQR(qrCode)
    },

    async logoutUser() {
        const owner = this.getOwnerProfile()
        let nodeId = "None"
        if (owner && owner.node_id) {
            nodeId = owner.node_id
        }
        await api.logoutUser(nodeId)
        this.reset();
    },

    async getProfile(userId) {
        const cacheKey = `user::${userId}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()
        const result = await api.getProfile({ownerNodeId: owner.node_id, userId: userId});
        stateMap.set(cacheKey, result);
        return result;
    },

    async getUsers({profileId, cursorReset}) {
        console.log("getUsers", profileId)

        let cursor = this.getCursor('users')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `users::${profileId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const result = await api.getUsers(
            {ownerNodeId: owner.node_id, userId: profileId, limit: defaultLimit, cursor: cursor},
        );
        if (!result) {
            return []
        }
        this.setCursor('users', result.cursor || "")
        if (!result.users || result.users.length === 0) {
            return []
        }

        result.users = result.users.filter(user => user.id !== profileId);

        for (const u of result.users) {
            stateMap.set(`user::${u.id}`, u);
        }

        stateMap.set(cacheKey, result.users);
        return result.users;
    },

    async getWhoToFollow(profileId, cursorReset) {
        let cursor = this.getCursor('whotofollow')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()

        if (!profileId || profileId === '') {
            profileId = owner.id
        }

        const req =  {
            ownerNodeId: owner.node_id,
            userId: profileId,
            limit: defaultLimit,
            cursor: cursor,
        }
        console.log("getWhoToFollow: request:", req);

        let result = await api.getWhoToFollow(req);
        console.log("getWhoToFollow: response:", result);

        if (!result) {
            return []
        }
        this.setCursor('whotofollow', result.cursor || "")

        return result.users;
    },

    async uploadImage(imgFile) {
        if (!imgFile) {
            return ''
        }
        const owner = this.getOwnerProfile()
        const hashKey = await api.uploadImage(
            {ownerNodeId: owner.node_id, imgFile: imgFile},
        );
        if (!hashKey || hashKey.length === 0) {
            return ''
        }
        this.invalidate(`user::${owner.id}`);

        const cacheKey = `image::${owner.id}::${hashKey}`;
        stateMap.set(cacheKey, imgFile);
        return hashKey;
    },

    async getImage({userId, key}) {
        if (!key || key.length === 0) {
            return null
        }

        const cacheKey = `image::${userId}::${key}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()
        const result = await api.getImage({ownerNodeId: owner.node_id, userId: userId, key: key});
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);

        return result;
    },

    async getMyTimeline(cursorReset) {
        let cursor = this.getCursor('timeline')
        if (cursorReset) {
            cursor = ''
        }
        console.log("timeline IN CURSOR", cursor)
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `timeline::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()
        const result = await api.getMyTimeline(
            {ownerNodeId: owner.node_id, ownerUserId: owner.id, limit: defaultLimit, cursor: cursor},
        );
        if (!result) {
            return []
        }

        console.log("timeline OUT CURSOR", result.cursor)

        this.setCursor('timeline', result.cursor || 'end')
        if (!result.tweets || result.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, result.tweets);

        return result.tweets;
    },

    async getTweets({userId,cursorReset}) {
        let cursor = this.getCursor('tweets')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `tweets::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()
        const result = await api.getTweets({
            ownerNodeId: owner.node_id,
            userId: userId,
            limit: defaultLimit,
            cursor: cursor
        });
        if (!result) {
            return []
        }
        this.setCursor('tweets', result.cursor || 'end')
        if (!result.tweets || result.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, result.tweets);

        return result.tweets;
    },

    async createTweet({text, imageKey}) {
        const owner = this.getOwnerProfile()
        const tweet = await api.createTweet(
            {
                ownerNodeId: owner.node_id, ownerUserId: owner.id, ownerUsername: owner.username,
                text: text, imageKey: imageKey,
            },
        );
        this.invalidate(`timeline`);
        this.invalidate(`tweets::${tweet.user_id}`);
        this.invalidate(`user::${tweet.user_id}`);

        const cacheKey = `tweet::${tweet.user_id}::${tweet.id}`;
        stateMap.set(cacheKey, tweet)
        return tweet;
    },

    async deleteTweet({userId, tweetId}) {
        const owner = this.getOwnerProfile()
        const result = await api.deleteTweet({ownerNodeId: owner.node_id, userId: userId, tweetId: tweetId});
        this.invalidate(`timeline`);
        this.invalidate(`tweets::${userId}`);
        stateMap.delete(`tweet::${userId}::${tweetId}`)
        return result;
    },

    async getTweet({userId, tweetId}) {
        const cacheKey = `tweet::${userId}::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const result = await api.getTweet({ownerNodeId: owner.node_id, userId: userId, tweetId: tweetId});
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);
        return result;
    },

    async followUser(profileId) {
        const owner = this.getOwnerProfile()
        const result = await api.followUser(
            {ownerNodeId: owner.node_id, ownerUserId: owner.id, profileId: profileId},
        );
        if (!result) {
            return null
        }
        const cacheKey = `isFollowed::${profileId}`;
        stateMap.set(cacheKey, {})
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.id}`);
        return result;
    },

    isFollowed(profileId) {
        const cacheKey = `isFollowed::${profileId}`;
        return stateMap.has(cacheKey);
    },

    isFollower(profileId) {
        const cacheKey = `isFollower::${profileId}`;
        return stateMap.has(cacheKey)
    },

    async unfollowUser(profileId) {
        const owner = this.getOwnerProfile()
        const result = await api.unfollowUser({
            ownerNodeId: owner.node_id,
            ownerUserId: owner.id,
            profileId: profileId
        });
        if (!result) {
            return null
        }
        stateMap.delete(`isFollowed::${profileId}`);
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.id}`);
        return result;
    },

    async getFollowers({userId, cursorReset}) {
        let cursor = this.getCursor('followers')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followers::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const result = await api.getFollowers(
            {ownerNodeId: owner.node_id, userId: userId, limit: defaultLimit, cursor: cursor},
        );
        if (!result) {
            return []
        }
        this.setCursor('followers', result.cursor || 'end')
        if (!result.followers || result.followers.length === 0) {
            return []
        }
        result.followers = result.followers.filter(follower => follower !== userId);

        stateMap.set(cacheKey, result.followers);
        for (const follower of result.followers || []) {
            const followerKey = `isFollower::${follower}`;
            stateMap.set(followerKey, {})
        }

        return result.followers;
    },

    async getFollowees({userId, cursorReset}) {
        let cursor = this.getCursor('followees')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followees::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const result = await api.getFollowing(
            {ownerNodeId: owner.node_id, userId: userId, limit: defaultLimit, cursor: cursor},
        );
        if (!result) {
            return []
        }
        this.setCursor('followees', result.cursor || 'end')
        if (!result.followees || result.followees.length === 0) {
            return []
        }
        result.followees = result.followees.filter(followee => followee !== userId);

        stateMap.set(cacheKey, result.followees);
        return result.followees;
    },

    async getTweetStats(tweetId, userId) {
        const cacheKey = `tweetstats::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const result = await api.getTweetStats(
            {ownerNodeId: owner.node_id, userId:userId, tweetId: tweetId},
        );
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);

        return result;
    },

    // create reply
    async replyTweet({rootId, parentId, parentUserId, text}) {
        const owner = this.getOwnerProfile()
        const result = await api.replyTweet(
            {
                ownerNodeId: owner.node_id, ownerUserId: owner.id, rootId: rootId,
                username: owner.username, parentId: parentId, parentUserId: parentUserId, text: text,
            },
        );
        if (!result) {
            return null
        }
        const cacheKey = `reply::${rootId}::${result.id}`;
        stateMap.set(cacheKey, result);
        this.invalidate(`replies::${rootId}`)
        this.invalidate(`tweetstats::${rootId}`)
        return result;
    },

    async getReplies({rootId, parentId, cursorReset}) {
        let cursor = this.getCursor('replies')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `replies::${rootId}::${parentId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const result = await api.getReplies(
            {ownerNodeId: owner.node_id, rootId: rootId, parentId: parentId, limit: defaultLimit, cursor: cursor},
        );
        if (!result) {
            return []
        }
        this.setCursor('replies', result.cursor || 'end')
        if (!result.replies || result.replies.length === 0) {
            return []
        }
        stateMap.set(cacheKey, result.replies);
        return result.replies;
    },

    async getReply({rootId, replyId}) {
        const cacheKey = `reply::${rootId}::${replyId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const result = await api.getTweetReply({ownerNodeId: owner.node_id, rootId: rootId, replyId: replyId});
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);
        return result;
    },

    async deleteReply({userId, rootId, replyId}) {
        const owner = this.getOwnerProfile()
        const result = await api.deleteTweetReply({
            ownerNodeId: owner.node_id,
            userId: userId,
            rootId: rootId,
            replyId: replyId
        });
        const cacheKey = `reply::${rootId}::${replyId}`;
        stateMap.delete(cacheKey);
        this.invalidate(`tweetstats::${rootId}`)
        this.invalidate(`replies::${rootId}`)
        return result;
    },

    async likeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()
        const result = await api.likeTweet(
            {ownerNodeId: owner.node_id, ownerUserId: owner.id,userId: userId, tweetId: tweetId},
        );
        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async unlikeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()
        const result = await api.unlikeTweet(
            {ownerNodeId: owner.node_id, ownerUserId: owner.id,userId: userId, tweetId: tweetId},
        );
        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async setLiker(tweetId, profileId, profileObj) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async retweetTweet({tweetId, userId, username, text}) {
        const owner = this.getOwnerProfile()
        const result = await api.retweetTweet(
            {
                ownerNodeId: owner.node_id, ownerUserId: owner.id, tweetId: tweetId,
                userId: userId, username: username, text: text,
            },
        );
        this.invalidate(`timeline`)
        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async unretweetTweet(tweetId) {
        const owner = this.getOwnerProfile()
        const result = await api.unretweetTweet(
            {ownerNodeId: owner.node_id, ownerUserId: owner.id, tweetId: tweetId},
        );
        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async setRetweeter(tweetId, profileId, profileObj) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async createChat(otherUserId) {
        const owner = this.getOwnerProfile()
        const chat = await api.createChat({
            ownerNodeId: owner.node_id,
            ownerUserId: owner.id,
            otherUserId: otherUserId
        });
        if (!chat) {
            return null
        }
        this.invalidate('chats')
        const cacheKey = `chat::${chat.id}`
        stateMap.set(cacheKey, chat)
        return chat;
    },

    async getChat(chatId) {
        const cacheKey = `chat::${chatId}`
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const chat = await api.getChat({ownerNodeId: owner.node_id, chatId: chatId});
        if (!chat) {
            return null
        }
        stateMap.set(cacheKey, chat)
        return chat;
    },

    async getChats(cursorReset) {
        let cursor = this.getCursor('chats')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()
        const cacheKey = `chats::${owner.id}::${defaultLimit}::${cursor}`

        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const result = await api.getChats(
            {ownerNodeId: owner.node_id, ownerUserId: owner.id, limit: defaultLimit, cursor: cursor},
        );
        if (!result) {
            return []
        }
        this.setCursor('chats', result.cursor || 'end')
        if (!result.chats || result.chats.length === 0) {
            return []
        }

        for (const chat of result.chats) {
            stateMap.set(`chat::${chat.id}`, chat)
        }

        stateMap.set(cacheKey, result.chats)
        return result.chats;
    },

    async sendDirectMessage({chatId, receiverId, text}) {
        const owner = this.getOwnerProfile();
        return await api.sendDirectMessage(
            {
                ownerNodeId:owner.node_id,
                ownerUserId: owner.id,
                receiverId: receiverId,
                chatId:chatId,
                text:text,
            }
        )
    },

    async getDirectMessages({chatId, cursorReset}) {
        let cursor = this.getCursor('messages')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile();

        const cacheKey = `messages::${owner.id}::${defaultLimit}::${cursor}`

        const result = await api.getDirectMessages(
            {ownerNodeId:owner.node_id, ownerUserId:owner.id,  chatId:chatId, limit:defaultLimit, cursor:cursor},
        )
        if (!result) {
            return []
        }
        this.setCursor('messages', result.cursor || 'end')
        if (!result.messages || result.messages.length === 0) {
            return []
        }

        stateMap.set(cacheKey, result.messages)
        return result.messages;
    },

    async editMyProfile(newProfile) {
        const owner = this.getOwnerProfile();
        return await api.editMyProfile({ownerNodeId:owner.node_id, newProfile:newProfile})
    },

    async resetConsensus() {
        return await api.resetConsensus('None')
    },

    async getNodeInfo(){
        const owner = this.getOwnerProfile();
        return await api.getNodeInfo(owner.node_id)
    }
}

// TTL in ms
const ttlMap = {
    'image': 6_000_000,
    'user': 60_000,
    'timeline': 6_000,
    'replies': 6_000,
    'tweetstats': 6_000,
}

function startCacheCleaner() {
    setInterval(() => {
        for (const [prefix, ttl] of Object.entries(ttlMap)) {
            const expirationKey = `${prefix}::expiration`;
            const expiration = stateMap.get(expirationKey) || {createdAt: 0};
            const now = Date.now();

            if (now - expiration.createdAt > ttl) {
                warpnetService.invalidate(prefix);
                stateMap.set(expirationKey, {createdAt: now});
            }
        }
    }, 1000);
}

startCacheCleaner();