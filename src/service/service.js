/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/Warp-net,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

WarpNet is provided “as is” without warranty of any kind, either expressed or implied.
Use at your own risk. The maintainers shall not be liable for any damages or data loss
resulting from the use or misuse of this software.
*/

import api from '@/lib/warpnet';
import {buildQRCode} from "@/lib/qr";

const stateMap = new Map();

const defaultLimit = 20
const endCursor = "end"

export const warpnetService = {
    reset() {
        stateMap.clear()
    },

    invalidate(prefix) {
        const keysToDelete = Array.from(stateMap.keys()).filter(k => k.startsWith(prefix));
        for (const key of keysToDelete) {
            stateMap.delete(key);
        }
    },
    setQR(qrData) {
        const key = `QR`;
        stateMap.set(key, qrData)
    },

    getQR() {
        const key = `QR`;
        return stateMap.get(key) || ""
    },

    setCursor(key, cursor) {
        const cacheKey = `${key}::cursor`;
        stateMap.set(cacheKey, cursor)
    },

    getCursor(key) {
        const cacheKey = `${key}::cursor`;
        return stateMap.get(cacheKey) || ""
    },

    setOwnerProfile(owner) {
        const key = `owner`;
        stateMap.set(key, owner)
    },

    getOwnerProfile() {
        const key = `owner`;
        return stateMap.get(key)
    },

    async signInUser(form) {
        const resp = await api.loginUser(form)
        if (!resp || !resp.identity) {
            throw new Error("Login failed: no response")
        }
        if (resp.code) {
            throw new Error(resp.message)
        }

        if (!resp.identity) {
            throw new Error("Login failed: no identity")
        }

        const qrData = JSON.stringify(resp);
        resp.identity.token = null // for security reasons

        if (!resp.identity.owner) {
            console.error("Login failed: owner identity not received")
            return;
        }

        const request = {
            path: PUBLIC_GET_USER,
            node_id: resp.identity.owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: resp.identity.owner.user_id,
            },
        }

        const ownerProfile = await window.go.main.App.Route(request);

        warpnetService.setOwnerProfile(ownerProfile)

        const qrCode = await buildQRCode(qrData)
        warpnetService.setQR(qrCode)
    },

    async logoutUser() {
        const owner = this.getOwnerProfile()
        let nodeId = "None"
        if (owner && owner.node_id) {
            nodeId = owner.node_id
        }
        await api.logoutUser(nodeId)
        this.reset();
    },

    async getProfile(userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_USER,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
            },
        }

        return await window.go.main.App.Route(request);
    },

    async getUsers({profileId, cursorReset}) {
        console.log("getUsers", profileId)

        let cursor = this.getCursor('users')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `users::${profileId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_USERS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: profileId,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('users', result.cursor || "")
        if (!result.users || result.users.length === 0) {
            return []
        }

        result.users = result.users.filter(user => user.id !== profileId);

        for (const u of result.users) {
            stateMap.set(`user::${u.id}`, u);
        }

        stateMap.set(cacheKey, result.users);
        return result.users;
    },

    async getWhoToFollow(profileId, cursorReset) {
        let cursor = this.getCursor('whotofollow')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()

        if (!profileId || profileId === '') {
            profileId = owner.id
        }

        const request = {
            path: PUBLIC_GET_WHOTOFOLLOW,
                node_id: owner.node_id,
                timestamp: new Date().toISOString(),
                body: {
                limit: defaultLimit,
                    cursor: cursor,
                    user_id: profileId,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('whotofollow', result.cursor || "")

        return result.users;
    },

    async uploadImage(imgFile) {
        if (!imgFile) {
            return ''
        }
        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_POST_UPLOAD_IMAGE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                file: imgFile,
            },
        }

        const hashKey = await window.go.main.App.Route(request);
        if (!hashKey || hashKey.length === 0) {
            return ''
        }
        this.invalidate(`user::${owner.id}`);

        const cacheKey = `image::${owner.id}::${hashKey}`;
        stateMap.set(cacheKey, imgFile);
        return hashKey;
    },

    async getImage({userId, key}) {
        if (!key || key.length === 0) {
            return null
        }

        const cacheKey = `image::${userId}::${key}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_IMAGE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                key: key,
            }
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);

        return result;
    },

    async getMyTimeline(cursorReset) {
        let cursor = this.getCursor('timeline')
        if (cursorReset) {
            cursor = ''
        }
        console.log("timeline IN CURSOR", cursor)
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `timeline::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_GET_TIMELINE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }

        this.setCursor('timeline', result.cursor || 'end')
        if (!result.tweets || result.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, result.tweets);

        return result.tweets;
    },

    async getTweets({userId,cursorReset}) {
        let cursor = this.getCursor('tweets')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `tweets::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_TWEETS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: userId,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('tweets', result.cursor || 'end')
        if (!result.tweets || result.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, result.tweets);

        return result.tweets;
    },

    async createTweet({text, imageKey}) {
        const owner = this.getOwnerProfile()

        const request ={
            path: PRIVATE_POST_TWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: owner.id,
                username: owner.username,
                text: text,
                image_key: imageKey,
                created_at: new Date().toISOString(),
            },
        }

        const tweet = await window.go.main.App.Route(request);

        this.invalidate(`timeline`);
        this.invalidate(`tweets::${tweet.user_id}`);
        this.invalidate(`user::${tweet.user_id}`);

        const cacheKey = `tweet::${tweet.user_id}::${tweet.id}`;
        stateMap.set(cacheKey, tweet)
        return tweet;
    },

    async deleteTweet({userId, tweetId}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_DELETE_TWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);

        this.invalidate(`timeline`);
        this.invalidate(`tweets::${userId}`);
        stateMap.delete(`tweet::${userId}::${tweetId}`)
        return result;
    },

    async getTweet({userId, tweetId}) {
        const cacheKey = `tweet::${userId}::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_TWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);
        return result;
    },

    async followUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_FOLLOW,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                followee: profileId,
                follower: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        const cacheKey = `isFollowed::${profileId}`;
        stateMap.set(cacheKey, {})
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.id}`);
        return result;
    },

    isFollowed(profileId) {
        const cacheKey = `isFollowed::${profileId}`;
        return stateMap.has(cacheKey);
    },

    isFollower(profileId) {
        const cacheKey = `isFollower::${profileId}`;
        return stateMap.has(cacheKey)
    },

    async unfollowUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNFOLLOW,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                followee: profileId,
                follower: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        stateMap.delete(`isFollowed::${profileId}`);
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.id}`);
        return result;
    },

    async getFollowers({userId, cursorReset}) {
        let cursor = this.getCursor('followers')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followers::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_FOLLOWERS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('followers', result.cursor || 'end')
        if (!result.followers || result.followers.length === 0) {
            return []
        }
        result.followers = result.followers.filter(follower => follower !== userId);

        stateMap.set(cacheKey, result.followers);
        for (const follower of result.followers || []) {
            const followerKey = `isFollower::${follower}`;
            stateMap.set(followerKey, {})
        }

        return result.followers;
    },

    async getFollowees({userId, cursorReset}) {
        let cursor = this.getCursor('followees')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followees::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_FOLLOWEES,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('followees', result.cursor || 'end')
        if (!result.followees || result.followees.length === 0) {
            return []
        }
        result.followees = result.followees.filter(followee => followee !== userId);

        stateMap.set(cacheKey, result.followees);
        return result.followees;
    },

    async getTweetStats(tweetId, userId) {
        const cacheKey = `tweetstats::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_TWEET_STATS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);

        return result;
    },

    // create reply
    async replyTweet({rootId, parentId, parentUserId, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_REPLY,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                root_id: rootId,
                parent_id: parentId,
                user_id: owner.id,
                username: owner.username,
                parent_user_id: parentUserId,
                text: text,
                created_at: new Date().toISOString(),
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        const cacheKey = `reply::${rootId}::${result.id}`;
        stateMap.set(cacheKey, result);
        this.invalidate(`replies::${rootId}`)
        this.invalidate(`tweetstats::${rootId}`)
        return result;
    },

    async getReplies({rootId, parentId, cursorReset}) {
        let cursor = this.getCursor('replies')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `replies::${rootId}::${parentId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_REPLIES,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                root_id: rootId,
                parent_id: parentId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('replies', result.cursor || 'end')
        if (!result.replies || result.replies.length === 0) {
            return []
        }
        stateMap.set(cacheKey, result.replies);
        return result.replies;
    },

    async getReply({rootId, replyId}) {
        const cacheKey = `reply::${rootId}::${replyId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const request = {
            path: PUBLIC_GET_REPLY,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                root_id: rootId,
                reply_id: replyId,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result);
        return result;
    },

    async deleteReply({userId, rootId, replyId}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_DELETE_REPLY,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                root_id: rootId,
                reply_id: replyId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const cacheKey = `reply::${rootId}::${replyId}`;
        stateMap.delete(cacheKey);
        this.invalidate(`tweetstats::${rootId}`)
        this.invalidate(`replies::${rootId}`)
        return result;
    },

    async likeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_LIKE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async unlikeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNLIKE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async setLiker(tweetId, profileId, profileObj) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async retweetTweet({tweetId, userId, username, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_RETWEET,
            node_id:  owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                id: tweetId,
                user_id: userId,
                username: username,
                text: text,
                retweeted_by: owner.id,
                created_at: new Date().toISOString(),
            },
        }

        const result = await window.go.main.App.Route(request);

        this.invalidate(`timeline`)
        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async unretweetTweet(tweetId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNRETWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                retweeter_id: owner.id,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);

        this.invalidate(`tweetstats::${tweetId}`)
        return result;
    },

    async setRetweeter(tweetId, profileId, profileObj) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async createChat(otherUserId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_CHAT,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                owner_id: owner.id,
                other_user_id: otherUserId,
            },
        }

        const chat = await window.go.main.App.Route(request);
        if (!chat) {
            return null
        }
        this.invalidate('chats')
        const cacheKey = `chat::${chat.id}`
        stateMap.set(cacheKey, chat)
        return chat;
    },

    async getChat(chatId) {
        const cacheKey = `chat::${chatId}`
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_GET_CHAT,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                chat_id: chatId,
            },
        }

        const chat = await window.go.main.App.Route(request);
        if (!chat) {
            return null
        }
        stateMap.set(cacheKey, chat)
        return chat;
    },

    async getChats(cursorReset) {
        let cursor = this.getCursor('chats')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()
        const cacheKey = `chats::${owner.id}::${defaultLimit}::${cursor}`

        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PRIVATE_GET_CHATS,
                node_id: owner.node_id,
                timestamp: new Date().toISOString(),
                body: {
                user_id: owner.id,
                    limit: defaultLimit,
                    cursor: cursor,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('chats', result.cursor || 'end')
        if (!result.chats || result.chats.length === 0) {
            return []
        }

        for (const chat of result.chats) {
            stateMap.set(`chat::${chat.id}`, chat)
        }

        stateMap.set(cacheKey, result.chats)
        return result.chats;
    },

    async sendDirectMessage({chatId, receiverId, text}) {
        const owner = this.getOwnerProfile();
        const request = {
            path: PUBLIC_POST_MESSAGE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                sender_id: owner.id,
                receiver_id: receiverId,
                chat_id: chatId,
                text: text,
            },
        }

        return await window.go.main.App.Route(request);
    },

    async getDirectMessages({chatId, cursorReset}) {
        let cursor = this.getCursor('messages')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile();

        const cacheKey = `messages::${owner.id}::${defaultLimit}::${cursor}`

        const request = {
            path: PRIVATE_GET_MESSAGES,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                owner_id: owner.id,
                chat_id: chatId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return []
        }
        this.setCursor('messages', result.cursor || 'end')
        if (!result.messages || result.messages.length === 0) {
            return []
        }

        stateMap.set(cacheKey, result.messages)
        return result.messages;
    },

    async editMyProfile(newProfile) {
        const owner = this.getOwnerProfile();
        const request = {
            path: PRIVATE_POST_USER,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                bio: newProfile.bio,
                avatar: newProfile.avatar,
                avatar_key: newProfile.avatar_key,
                username: newProfile.username,
                background_image: newProfile.background_image,
                background_image_key: newProfile.background_image_key,
                website: newProfile.website,
                birthdate: newProfile.birthdate,
            },
        }

        return await window.go.main.App.Route(request);
    },

    async getNodeInfo(){
        const owner = this.getOwnerProfile();
        const request = {
            path: PRIVATE_GET_STATS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {},
        }

        return await window.go.main.App.Route(request);
    }
}

// TTL in ms
const ttlMap = {
    'image': 6_000_000,
    'user': 60_000,
    'timeline': 6_000,
    'replies': 6_000,
    'tweetstats': 6_000,
}

function startCacheCleaner() {
    setInterval(() => {
        for (const [prefix, ttl] of Object.entries(ttlMap)) {
            const expirationKey = `${prefix}::expiration`;
            const expiration = stateMap.get(expirationKey) || {createdAt: 0};
            const now = Date.now();

            if (now - expiration.createdAt > ttl) {
                warpnetService.invalidate(prefix);
                stateMap.set(expirationKey, {createdAt: now});
            }
        }
    }, 1000);
}

startCacheCleaner();