/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/Warp-net,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

WarpNet is provided “as is” without warranty of any kind, either expressed or implied.
Use at your own risk. The maintainers shall not be liable for any damages or data loss
resulting from the use or misuse of this software.
*/

import {buildQRCode} from "@/lib/qr";
import {generateUUID} from "@/lib/uuid";
import {Call} from "../../wailsjs/go/main/App";

export const PUBLIC_GET_TWEET = "/public/get/tweet/0.0.0"
export const PUBLIC_GET_TWEET_STATS   = "/public/get/tweetstats/0.0.0"
export const PRIVATE_GET_TIMELINE = "/private/get/timeline/0.0.0"
export const PUBLIC_GET_TWEETS = "/public/get/tweets/0.0.0"
export const PUBLIC_POST_UNLIKE = "/public/post/unlike/0.0.0"
export const PRIVATE_POST_TWEET = "/private/post/tweet/0.0.0"
export const PUBLIC_POST_REPLY = "/public/post/reply/0.0.0"
export const PUBLIC_GET_FOLLOWEES = "/public/get/followees/0.0.0"
export const PUBLIC_GET_REPLY = "/public/get/reply/0.0.0"
export const PRIVATE_GET_STATS = "/private/get/admin/stats/0.0.0"
export const PRIVATE_POST_RESET       = "/private/post/reset/0.0.0"
export const PUBLIC_DELETE_REPLY = "/public/delete/reply/0.0.0"
export const PRIVATE_DELETE_TWEET = "/private/delete/tweet/0.0.0"
export const PRIVATE_POST_USER = "/private/post/user/0.0.0"
export const PUBLIC_POST_UNFOLLOW = "/public/post/unfollow/0.0.0"
export const PUBLIC_GET_USER = "/public/get/user/0.0.0"
export const PUBLIC_GET_USERS = "/public/get/users/0.0.0"
export const PUBLIC_GET_WHOTOFOLLOW = "/public/get/whotofollow/0.0.0"
export const PUBLIC_GET_REPLIES = "/public/get/replies/0.0.0"
export const PUBLIC_GET_FOLLOWERS = "/public/get/followers/0.0.0"
export const PUBLIC_POST_FOLLOW = "/public/post/follow/0.0.0"
export const PUBLIC_POST_LIKE = "/public/post/like/0.0.0"
export const PUBLIC_POST_RETWEET = "/public/post/retweet/0.0.0"
export const PUBLIC_POST_UNRETWEET = "/public/post/unretweet/0.0.0"
export const PUBLIC_POST_CHAT = "/public/post/chat/0.0.0"
export const PRIVATE_DELETE_CHAT = "/private/delete/chat/0.0.0"
export const PRIVATE_GET_CHATS = "/private/get/chats/0.0.0"
export const PRIVATE_GET_CHAT = "/private/get/chat/0.0.0"
export const PRIVATE_GET_MESSAGES = "/private/get/messages/0.0.0"
export const PUBLIC_POST_MESSAGE = "/public/post/message/0.0.0"
export const PRIVATE_GET_MESSAGE = "/private/get/message/0.0.0"
export const PUBLIC_DELETE_MESSAGE = "/public/delete/message/0.0.0"
export const PRIVATE_POST_UPLOAD_IMAGE = "/private/post/image/0.0.0"
export const PUBLIC_GET_IMAGE = "/public/get/image/0.0.0"
export const PRIVATE_POST_LOGIN = "/private/post/login/0.0.0"
export const PRIVATE_POST_LOGOUT = "/private/post/logout/0.0.0"

const stateMap = new Map();
const defaultLimit = 20
const endCursor = "end"

export const warpnetService = {
    reset() {
        stateMap.clear()
    },

    invalidate(prefix) {
        const keysToDelete = Array.from(stateMap.keys()).filter(k => k.startsWith(prefix));
        for (const key of keysToDelete) {
            stateMap.delete(key);
        }
    },
    setQR(qrData) {
        const key = `QR`;
        stateMap.set(key, qrData)
    },

    getQR() {
        const key = `QR`;
        return stateMap.get(key) || ""
    },

    setCursor(key, cursor) {
        const cacheKey = `${key}::cursor`;
        stateMap.set(cacheKey, cursor)
    },

    getCursor(key) {
        const cacheKey = `${key}::cursor`;
        return stateMap.get(cacheKey) || ""
    },

    setOwnerProfile(owner) {
        const key = `owner`;
        stateMap.set(key, owner)
    },

    getOwnerProfile() {
        const key = `owner`;
        return stateMap.get(key)
    },

    async signInUser(form) {
        let request = {
            path: PRIVATE_POST_LOGIN,
            body: {
                username: form.username,
                password: form.password,
            }
        }
        const resp = await this.sendToNode(request);
        if (!resp || !resp.identity) {
            alert("Login failed: no response")
            throw new Error("Login failed: no response")
        }
        if (resp.code) {
            alert(resp.message)
            throw new Error(resp.message)
        }

        if (!resp.identity) {
            alert("Login failed: no identity")
            throw new Error("Login failed: no identity")
        }

        const qrData = JSON.stringify(resp);
        resp.identity.token = null // for security reasons

        if (!resp.identity.owner) {
            alert("Login failed: owner identity not received")
            console.error("Login failed: owner identity not received")
            return;
        }

        warpnetService.setOwnerProfile(resp.identity.owner)

        const qrCode = await buildQRCode(qrData)
        warpnetService.setQR(qrCode)
    },

    async logoutUser() {
        const request = {
            path: PRIVATE_POST_LOGOUT,
            body: {}
        }

        await this.sendToNode(request);
        this.reset();
    },

    async getProfile(userId) {
        const request = {
            path: PUBLIC_GET_USER,
            body: {
                user_id: userId,
            },
        }

        return await this.sendToNode(request);
    },

    async getUsers({profileId, cursorReset}) {
        console.log("getUsers", profileId)

        let cursor = this.getCursor('users')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `users::${profileId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);


        const request = {
            path: PUBLIC_GET_USERS,
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: profileId,
            },
        }

        const usersResp = await this.sendToNode(request);
        if (!usersResp) {
            return []
        }
        this.setCursor('users', usersResp.cursor || "")
        if (!usersResp.users || usersResp.users.length === 0) {
            return []
        }

        usersResp.users = usersResp.users.filter(user => user.id !== profileId);

        for (const u of usersResp.users) {
            stateMap.set(`user::${u.id}`, u);
        }

        stateMap.set(cacheKey, usersResp.users);
        return usersResp.users;
    },

    async getWhoToFollow(profileId, cursorReset) {
        let cursor = this.getCursor('whotofollow')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()

        if (!profileId || profileId === '') {
            profileId = owner.id
        }

        const request = {
            path: PUBLIC_GET_WHOTOFOLLOW,
            body: {
            limit: defaultLimit,
                cursor: cursor,
                user_id: profileId,
            },
        }

        const followResp = await this.sendToNode(request);
        if (!followResp) {
            return []
        }
        this.setCursor('whotofollow', followResp.cursor || "")

        return followResp.users;
    },

    async uploadImage(imgFile) {
        if (!imgFile) {
            return ''
        }
        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_POST_UPLOAD_IMAGE,
            timestamp: new Date().toISOString(),
            body: {
                file: imgFile,
            },
        }

        const result = await this.sendToNode(request);
        const hashKey = result.key
        if (!hashKey || hashKey.length === 0) {
            return ''
        }
        this.invalidate(`user::${owner.user_id}`);

        const cacheKey = `image::${owner.user_id}::${hashKey}`;
        stateMap.set(cacheKey, imgFile);
        return hashKey;
    },

    async getImage({userId, key}) {
        if (!key || key.length === 0) {
            return null
        }

        const cacheKey = `image::${userId}::${key}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const request = {
            path: PUBLIC_GET_IMAGE,
            body: {
                user_id: userId,
                key: key,
            }
        }

        const result = await this.sendToNode(request);
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result.file);

        return result.file;
    },

    async getMyTimeline(cursorReset) {
        let cursor = this.getCursor('timeline')
        if (cursorReset) {
            cursor = ''
        }
        console.log("timeline IN CURSOR", cursor)
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `timeline::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_GET_TIMELINE,
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: owner.user_id,
            },
        }

        const timelineResp = await this.sendToNode(request);
        if (!timelineResp) {
            return []
        }

        this.setCursor('timeline', timelineResp.cursor || 'end')
        if (!timelineResp.tweets || timelineResp.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, timelineResp.tweets);

        return timelineResp.tweets;
    },

    async getTweets({userId,cursorReset}) {
        let cursor = this.getCursor('tweets')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `tweets::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const request = {
            path: PUBLIC_GET_TWEETS,
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: userId,
            },
        }

        const tweetsResp = await this.sendToNode(request);
        if (!tweetsResp) {
            return []
        }
        this.setCursor('tweets', tweetsResp.cursor || 'end')
        if (!tweetsResp.tweets || tweetsResp.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, tweetsResp.tweets);

        return tweetsResp.tweets;
    },

    async createTweet({text, imageKey}) {
        const owner = this.getOwnerProfile()

        const request ={
            path: PRIVATE_POST_TWEET,
            body: {
                user_id: owner.user_id,
                username: owner.username,
                text: text,
                image_key: imageKey,
                created_at: new Date().toISOString(),
            },
        }

        const tweet = await this.sendToNode(request);

        this.invalidate(`timeline`);
        this.invalidate(`tweets::${tweet.user_id}`);
        this.invalidate(`user::${tweet.user_id}`);

        const cacheKey = `tweet::${tweet.user_id}::${tweet.id}`;
        stateMap.set(cacheKey, tweet)
        return tweet;
    },

    async deleteTweet({userId, tweetId}) {
        const request = {
            path: PRIVATE_DELETE_TWEET,
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const tweet = await this.sendToNode(request);

        this.invalidate(`timeline`);
        this.invalidate(`tweets::${userId}`);
        stateMap.delete(`tweet::${userId}::${tweetId}`)
        return tweet;
    },

    async getTweet({userId, tweetId}) {
        const cacheKey = `tweet::${userId}::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PUBLIC_GET_TWEET,
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const tweet = await this.sendToNode(request);
        if (!tweet) {
            return null
        }
        stateMap.set(cacheKey, tweet);
        return tweet;
    },

    async followUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_FOLLOW,
            body: {
                followee: profileId,
                follower: owner.user_id,
            },
        }

        const followResp = await this.sendToNode(request);
        if (!followResp) {
            return null
        }
        const cacheKey = `isFollowed::${profileId}`;
        stateMap.set(cacheKey, {})
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.user_id}`);
        return followResp;
    },

    isFollowed(profileId) {
        const cacheKey = `isFollowed::${profileId}`;
        return stateMap.has(cacheKey);
    },

    isFollower(profileId) {
        const cacheKey = `isFollower::${profileId}`;
        return stateMap.has(cacheKey)
    },

    async unfollowUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNFOLLOW,
            body: {
                followee: profileId,
                follower: owner.user_id,
            },
        }

        const unfollowResp = await this.sendToNode(request);
        if (!unfollowResp) {
            return null
        }
        stateMap.delete(`isFollowed::${profileId}`);
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.user_id}`);
        return unfollowResp;
    },

    async getFollowers({userId, cursorReset}) {
        let cursor = this.getCursor('followers')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followers::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PUBLIC_GET_FOLLOWERS,
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const followersResp = await this.sendToNode(request);
        if (!followersResp) {
            return []
        }
        this.setCursor('followers', followersResp.cursor || 'end')
        if (!followersResp.followers || followersResp.followers.length === 0) {
            return []
        }
        followersResp.followers = followersResp.followers.filter(follower => follower !== userId);

        stateMap.set(cacheKey, followersResp.followers);
        for (const follower of followersResp.followers || []) {
            const followerKey = `isFollower::${follower}`;
            stateMap.set(followerKey, {})
        }

        return followersResp.followers;
    },

    async getFollowees({userId, cursorReset}) {
        let cursor = this.getCursor('followees')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followees::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PUBLIC_GET_FOLLOWEES,
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const followeesResp = await this.sendToNode(request);
        if (!followeesResp) {
            return []
        }
        this.setCursor('followees', followeesResp.cursor || 'end')
        if (!followeesResp.followees || followeesResp.followees.length === 0) {
            return []
        }
        followeesResp.followees = followeesResp.followees.filter(followee => followee !== userId);

        stateMap.set(cacheKey, followeesResp.followees);
        return followeesResp.followees;
    },

    async getTweetStats(tweetId, userId) {
        const cacheKey = `tweetstats::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PUBLIC_GET_TWEET_STATS,
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const statsResp = await this.sendToNode(request);
        if (!statsResp) {
            return null
        }
        stateMap.set(cacheKey, statsResp);

        return statsResp;
    },

    // create reply
    async replyTweet({rootId, parentId, parentUserId, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_REPLY,
            body: {
                root_id: rootId,
                parent_id: parentId,
                user_id: owner.user_id,
                username: owner.username,
                parent_user_id: parentUserId,
                text: text,
                created_at: new Date().toISOString(),
            },
        }

        const replyResp = await this.sendToNode(request);
        if (!replyResp) {
            return null
        }
        const cacheKey = `reply::${rootId}::${replyResp.id}`;
        stateMap.set(cacheKey, replyResp);
        this.invalidate(`replies::${rootId}`)
        this.invalidate(`tweetstats::${rootId}`)
        return replyResp;
    },

    async getReplies({rootId, parentId, cursorReset}) {
        let cursor = this.getCursor('replies')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `replies::${rootId}::${parentId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PUBLIC_GET_REPLIES,
            body: {
                root_id: rootId,
                parent_id: parentId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const repliesResp = await this.sendToNode(request);
        if (!repliesResp) {
            return []
        }
        this.setCursor('replies', repliesResp.cursor || 'end')
        if (!repliesResp.replies || repliesResp.replies.length === 0) {
            return []
        }
        stateMap.set(cacheKey, repliesResp.replies);
        return repliesResp.replies;
    },

    async getReply({rootId, replyId}) {
        const cacheKey = `reply::${rootId}::${replyId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PUBLIC_GET_REPLY,
            body: {
                root_id: rootId,
                reply_id: replyId,
            },
        }

        const replyResp = await this.sendToNode(request);
        if (!replyResp) {
            return null
        }
        stateMap.set(cacheKey, replyResp);
        return replyResp;
    },

    async deleteReply({userId, rootId, replyId}) {
        const request = {
            path: PUBLIC_DELETE_REPLY,
            body: {
                user_id: userId,
                root_id: rootId,
                reply_id: replyId,
            },
        }

        const replyResp = await this.sendToNode(request);

        const cacheKey = `reply::${rootId}::${replyId}`;
        stateMap.delete(cacheKey);
        this.invalidate(`tweetstats::${rootId}`)
        this.invalidate(`replies::${rootId}`)
        return replyResp;
    },

    async likeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_LIKE,
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.user_id,
            },
        }

        const likeResp = await this.sendToNode(request);

        this.invalidate(`tweetstats::${tweetId}`)
        return likeResp.count;
    },

    async unlikeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNLIKE,
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.user_id,
            },
        }

        const unlikeResp = await this.sendToNode(request);

        this.invalidate(`tweetstats::${tweetId}`)
        return unlikeResp.count;
    },

    async setLiker(tweetId, profileId, profileObj) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async retweetTweet({tweetId, userId, username, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_RETWEET,
            body: {
                id: tweetId,
                user_id: userId,
                username: username,
                text: text,
                retweeted_by: owner.user_id,
                created_at: new Date().toISOString(),
            },
        }

        const retweetResp = await this.sendToNode(request);

        this.invalidate(`timeline`)
        this.invalidate(`tweetstats::${tweetId}`)
        return retweetResp;
    },

    async unretweetTweet(tweetId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNRETWEET,
            timestamp: new Date().toISOString(),
            body: {
                retweeter_id: owner.user_id,
                tweet_id: tweetId,
            },
        }

        const unretweetResp = await this.sendToNode(request);

        this.invalidate(`tweetstats::${tweetId}`)
        return unretweetResp;
    },

    async setRetweeter(tweetId, profileId, profileObj) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async createChat(otherUserId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_CHAT,
            body: {
                owner_id: owner.user_id,
                other_user_id: otherUserId,
            },
        }

        const chatResp = await this.sendToNode(request);
        if (!chatResp) {
            return null
        }
        this.invalidate('chats')
        const cacheKey = `chat::${chatResp.id}`
        stateMap.set(cacheKey, chatResp)
        return chatResp;
    },

    async getChat(chatId) {
        const cacheKey = `chat::${chatId}`
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PRIVATE_GET_CHAT,
            body: {
                chat_id: chatId,
            },
        }

        const chatResp = await this.sendToNode(request);
        if (!chatResp) {
            return null
        }
        stateMap.set(cacheKey, chatResp)
        return chatResp;
    },

    async getChats(cursorReset) {
        let cursor = this.getCursor('chats')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()
        const cacheKey = `chats::${owner.id}::${defaultLimit}::${cursor}`

        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PRIVATE_GET_CHATS,
            body: {
                user_id: owner.user_id,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const chatsResp = await this.sendToNode(request);
        if (!chatsResp) {
            return []
        }
        this.setCursor('chats', chatsResp.cursor || 'end')
        if (!chatsResp.chats || chatsResp.chats.length === 0) {
            return []
        }

        for (const chat of chatsResp.chats) {
            stateMap.set(`chat::${chat.id}`, chat)
        }

        stateMap.set(cacheKey, chatsResp.chats)
        return chatsResp.chats;
    },

    async sendDirectMessage({chatId, receiverId, text}) {
        const owner = this.getOwnerProfile();
        const request = {
            path: PUBLIC_POST_MESSAGE,
            body: {
                sender_id: owner.user_id,
                receiver_id: receiverId,
                chat_id: chatId,
                text: text,
            },
        }

        return await this.sendToNode(request);
    },

    async getDirectMessages({chatId, cursorReset}) {
        let cursor = this.getCursor('messages')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile();

        const cacheKey = `messages::${owner.id}::${defaultLimit}::${cursor}`

        const request = {
            path: PRIVATE_GET_MESSAGES,
            body: {
                owner_id: owner.user_id,
                chat_id: chatId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const messagesResp = await this.sendToNode(request);
        if (!messagesResp) {
            return []
        }
        this.setCursor('messages', messagesResp.cursor || 'end')
        if (!messagesResp.messages || messagesResp.messages.length === 0) {
            return []
        }

        stateMap.set(cacheKey, messagesResp.messages)
        return messagesResp.messages;
    },

    async editMyProfile(newProfile) {
        const request = {
            path: PRIVATE_POST_USER,
            body: {
                bio: newProfile.bio,
                avatar: newProfile.avatar,
                avatar_key: newProfile.avatar_key,
                username: newProfile.username,
                background_image: newProfile.background_image,
                background_image_key: newProfile.background_image_key,
                website: newProfile.website,
                birthdate: newProfile.birthdate,
            },
        }

        return await this.sendToNode(request);
    },

    async getNodeInfo(){
        const request = {
            path: PRIVATE_GET_STATS,
            body: {},
        }

        return await this.sendToNode(request);
    },

    async sendToNode(request) {
        const owner = this.getOwnerProfile()

        request.message_id = generateUUID()
        request.node_id = owner?.node_id || "None"
        request.timestamp = new Date().toISOString()

        const result = await Call(request);
        if (!result) {
            throw new Error(`Unable to send ${request.message_id}`);
        }
        return result.body;
    }
}

// TTL in ms
const ttlMap = {
    'image': 6_000_000,
    'user': 60_000,
    'timeline': 6_000,
    'replies': 6_000,
    'tweetstats': 6_000,
}

function startCacheCleaner() {
    setInterval(() => {
        for (const [prefix, ttl] of Object.entries(ttlMap)) {
            const expirationKey = `${prefix}::expiration`;
            const expiration = stateMap.get(expirationKey) || {createdAt: 0};
            const now = Date.now();

            if (now - expiration.createdAt > ttl) {
                warpnetService.invalidate(prefix);
                stateMap.set(expirationKey, {createdAt: now});
            }
        }
    }, 1000);
}

startCacheCleaner();

