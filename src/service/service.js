/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/Warp-net,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

WarpNet is provided “as is” without warranty of any kind, either expressed or implied.
Use at your own risk. The maintainers shall not be liable for any damages or data loss
resulting from the use or misuse of this software.
*/

import {buildQRCode} from "@/lib/qr";


const PUBLIC_GET_TWEET = "/public/get/tweet/0.0.0"
const PUBLIC_GET_TWEET_STATS   = "/public/get/tweetstats/0.0.0"
const PRIVATE_GET_TIMELINE = "/private/get/timeline/0.0.0"
const PUBLIC_GET_TWEETS = "/public/get/tweets/0.0.0"
const PUBLIC_POST_UNLIKE = "/public/post/unlike/0.0.0"
const PRIVATE_POST_TWEET = "/private/post/tweet/0.0.0"
const PUBLIC_POST_REPLY = "/public/post/reply/0.0.0"
const PUBLIC_GET_FOLLOWEES = "/public/get/followees/0.0.0"
const PUBLIC_GET_REPLY = "/public/get/reply/0.0.0"
const PRIVATE_GET_STATS = "/private/get/admin/stats/0.0.0"
const PRIVATE_POST_RESET       = "/private/post/reset/0.0.0"
const PUBLIC_DELETE_REPLY = "/public/delete/reply/0.0.0"
const PRIVATE_DELETE_TWEET = "/private/delete/tweet/0.0.0"
const PRIVATE_POST_USER = "/private/post/user/0.0.0"
const PUBLIC_POST_UNFOLLOW = "/public/post/unfollow/0.0.0"
const PUBLIC_GET_USER = "/public/get/user/0.0.0"
const PUBLIC_GET_USERS = "/public/get/users/0.0.0"
const PUBLIC_GET_WHOTOFOLLOW = "/public/get/whotofollow/0.0.0"
const PUBLIC_GET_REPLIES = "/public/get/replies/0.0.0"
const PUBLIC_GET_FOLLOWERS = "/public/get/followers/0.0.0"
const PUBLIC_POST_FOLLOW = "/public/post/follow/0.0.0"
const PUBLIC_POST_LIKE = "/public/post/like/0.0.0"
const PUBLIC_POST_RETWEET = "/public/post/retweet/0.0.0"
const PUBLIC_POST_UNRETWEET = "/public/post/unretweet/0.0.0"
const PUBLIC_POST_CHAT = "/public/post/chat/0.0.0"
const PRIVATE_DELETE_CHAT = "/private/delete/chat/0.0.0"
const PRIVATE_GET_CHATS = "/private/get/chats/0.0.0"
const PRIVATE_GET_CHAT = "/private/get/chat/0.0.0"
const PRIVATE_GET_MESSAGES = "/private/get/messages/0.0.0"
const PUBLIC_POST_MESSAGE = "/public/post/message/0.0.0"
const PRIVATE_GET_MESSAGE = "/private/get/message/0.0.0"
const PUBLIC_DELETE_MESSAGE = "/public/delete/message/0.0.0"
const PRIVATE_POST_UPLOAD_IMAGE = "/private/post/image/0.0.0"
const PUBLIC_GET_IMAGE = "/public/get/image/0.0.0"

const PRIVATE_POST_LOGIN = "/private/post/login/0.0.0"
const PRIVATE_POST_LOGOUT = "/private/post/logout/0.0.0"

const stateMap = new Map();

const defaultLimit = 20
const endCursor = "end"

export const warpnetService = {
    reset() {
        stateMap.clear()
    },

    invalidate(prefix) {
        const keysToDelete = Array.from(stateMap.keys()).filter(k => k.startsWith(prefix));
        for (const key of keysToDelete) {
            stateMap.delete(key);
        }
    },
    setQR(qrData) {
        const key = `QR`;
        stateMap.set(key, qrData)
    },

    getQR() {
        const key = `QR`;
        return stateMap.get(key) || ""
    },

    setCursor(key, cursor) {
        const cacheKey = `${key}::cursor`;
        stateMap.set(cacheKey, cursor)
    },

    getCursor(key) {
        const cacheKey = `${key}::cursor`;
        return stateMap.get(cacheKey) || ""
    },

    setOwnerProfile(owner) {
        const key = `owner`;
        stateMap.set(key, owner)
    },

    getOwnerProfile() {
        const key = `owner`;
        return stateMap.get(key)
    },

    async signInUser(form) {
        let request = {
            path: PRIVATE_POST_LOGIN,
            node_id: "None",
            body: {
                username: form.username,
                password: form.password,
            }
        }
        const result = await window.go.main.App.Route(request);
        const resp = result.body;
        if (!resp || !resp.identity) {
            alert("Login failed: no response")
            throw new Error("Login failed: no response")
        }
        if (resp.code) {
            alert(resp.message)
            throw new Error(resp.message)
        }

        if (!resp.identity) {
            alert("Login failed: no identity")
            throw new Error("Login failed: no identity")
        }

        const qrData = JSON.stringify(resp);
        resp.identity.token = null // for security reasons

        if (!resp.identity.owner) {
            alert("Login failed: owner identity not received")
            console.error("Login failed: owner identity not received")
            return;
        }

        request = {
            path: PUBLIC_GET_USER,
            node_id: resp.identity.owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: resp.identity.owner.user_id,
            },
        }

        const ownerProfile = await window.go.main.App.Route(request);

        warpnetService.setOwnerProfile(ownerProfile)

        const qrCode = await buildQRCode(qrData)
        warpnetService.setQR(qrCode)
    },

    async logoutUser() {
        const owner = this.getOwnerProfile()
        let nodeId = "None"
        if (owner && owner.node_id) {
            nodeId = owner.node_id
        }
        const request = {
                    path: PRIVATE_POST_LOGOUT,
                    node_id: nodeId,
                    body: {}
                }

        await window.go.main.App.Route(request);
        this.reset();
    },

    async getProfile(userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_USER,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
            },
        }

        const result = await window.go.main.App.Route(request);
        return result.body;
    },

    async getUsers({profileId, cursorReset}) {
        console.log("getUsers", profileId)

        let cursor = this.getCursor('users')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `users::${profileId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_USERS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: profileId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const usersResp = result.body;
        if (!usersResp) {
            return []
        }
        this.setCursor('users', usersResp.cursor || "")
        if (!usersResp.users || usersResp.users.length === 0) {
            return []
        }

        usersResp.users = usersResp.users.filter(user => user.id !== profileId);

        for (const u of usersResp.users) {
            stateMap.set(`user::${u.id}`, u);
        }

        stateMap.set(cacheKey, usersResp.users);
        return usersResp.users;
    },

    async getWhoToFollow(profileId, cursorReset) {
        let cursor = this.getCursor('whotofollow')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()

        if (!profileId || profileId === '') {
            profileId = owner.id
        }

        const request = {
            path: PUBLIC_GET_WHOTOFOLLOW,
                node_id: owner.node_id,
                timestamp: new Date().toISOString(),
                body: {
                limit: defaultLimit,
                    cursor: cursor,
                    user_id: profileId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const followResp = result.body;
        if (!followResp) {
            return []
        }
        this.setCursor('whotofollow', followResp.cursor || "")

        return followResp.users;
    },

    async uploadImage(imgFile) {
        if (!imgFile) {
            return ''
        }
        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_POST_UPLOAD_IMAGE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                file: imgFile,
            },
        }

        const result = await window.go.main.App.Route(request);
        const hashKey = result.body.key
        if (!hashKey || hashKey.length === 0) {
            return ''
        }
        this.invalidate(`user::${owner.id}`);

        const cacheKey = `image::${owner.id}::${hashKey}`;
        stateMap.set(cacheKey, imgFile);
        return hashKey;
    },

    async getImage({userId, key}) {
        if (!key || key.length === 0) {
            return null
        }

        const cacheKey = `image::${userId}::${key}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_IMAGE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                key: key,
            }
        }

        const result = await window.go.main.App.Route(request);
        if (!result) {
            return null
        }
        stateMap.set(cacheKey, result.file);

        return result.file;
    },

    async getMyTimeline(cursorReset) {
        let cursor = this.getCursor('timeline')
        if (cursorReset) {
            cursor = ''
        }
        console.log("timeline IN CURSOR", cursor)
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `timeline::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_GET_TIMELINE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        const timelineResp = result.body;
        if (!timelineResp) {
            return []
        }

        this.setCursor('timeline', timelineResp.cursor || 'end')
        if (!timelineResp.tweets || timelineResp.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, timelineResp.tweets);

        return timelineResp.tweets;
    },

    async getTweets({userId,cursorReset}) {
        let cursor = this.getCursor('tweets')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `tweets::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) {
            return stateMap.get(cacheKey);
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_TWEETS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: userId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const tweetsResp = result.body;
        if (!tweetsResp) {
            return []
        }
        this.setCursor('tweets', tweetsResp.cursor || 'end')
        if (!tweetsResp.tweets || tweetsResp.tweets.length === 0) {
            return []
        }
        stateMap.set(cacheKey, tweetsResp.tweets);

        return tweetsResp.tweets;
    },

    async createTweet({text, imageKey}) {
        const owner = this.getOwnerProfile()

        const request ={
            path: PRIVATE_POST_TWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: owner.id,
                username: owner.username,
                text: text,
                image_key: imageKey,
                created_at: new Date().toISOString(),
            },
        }

        const result = await window.go.main.App.Route(request);
        const tweet = result.body;

        this.invalidate(`timeline`);
        this.invalidate(`tweets::${tweet.user_id}`);
        this.invalidate(`user::${tweet.user_id}`);

        const cacheKey = `tweet::${tweet.user_id}::${tweet.id}`;
        stateMap.set(cacheKey, tweet)
        return tweet;
    },

    async deleteTweet({userId, tweetId}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_DELETE_TWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const tweet = result.body;

        this.invalidate(`timeline`);
        this.invalidate(`tweets::${userId}`);
        stateMap.delete(`tweet::${userId}::${tweetId}`)
        return tweet;
    },

    async getTweet({userId, tweetId}) {
        const cacheKey = `tweet::${userId}::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_TWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const tweet = result.body;
        if (!tweet) {
            return null
        }
        stateMap.set(cacheKey, tweet);
        return tweet;
    },

    async followUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_FOLLOW,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                followee: profileId,
                follower: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        const followResp = result.body;
        if (!followResp) {
            return null
        }
        const cacheKey = `isFollowed::${profileId}`;
        stateMap.set(cacheKey, {})
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.id}`);
        return followResp;
    },

    isFollowed(profileId) {
        const cacheKey = `isFollowed::${profileId}`;
        return stateMap.has(cacheKey);
    },

    isFollower(profileId) {
        const cacheKey = `isFollower::${profileId}`;
        return stateMap.has(cacheKey)
    },

    async unfollowUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNFOLLOW,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                followee: profileId,
                follower: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        const unfollowResp = result.body;
        if (!unfollowResp) {
            return null
        }
        stateMap.delete(`isFollowed::${profileId}`);
        this.invalidate(`followers::${profileId}`);
        this.invalidate(`followees::${profileId}`);
        this.invalidate(`user::${profileId}`);
        this.invalidate(`user::${owner.id}`);
        return unfollowResp;
    },

    async getFollowers({userId, cursorReset}) {
        let cursor = this.getCursor('followers')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followers::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_FOLLOWERS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const result = await window.go.main.App.Route(request);
        const followersResp = result.body;
        if (!followersResp) {
            return []
        }
        this.setCursor('followers', followersResp.cursor || 'end')
        if (!result.followers || result.followers.length === 0) {
            return []
        }
        followersResp.followers = followersResp.followers.filter(follower => follower !== userId);

        stateMap.set(cacheKey, followersResp.followers);
        for (const follower of followersResp.followers || []) {
            const followerKey = `isFollower::${follower}`;
            stateMap.set(followerKey, {})
        }

        return followersResp.followers;
    },

    async getFollowees({userId, cursorReset}) {
        let cursor = this.getCursor('followees')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `followees::${userId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_FOLLOWEES,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const result = await window.go.main.App.Route(request);
        const followeesResp = result.body;
        if (!followeesResp) {
            return []
        }
        this.setCursor('followees', followeesResp.cursor || 'end')
        if (!followeesResp.followees || followeesResp.followees.length === 0) {
            return []
        }
        followeesResp.followees = followeesResp.followees.filter(followee => followee !== userId);

        stateMap.set(cacheKey, followeesResp.followees);
        return followeesResp.followees;
    },

    async getTweetStats(tweetId, userId) {
        const cacheKey = `tweetstats::${tweetId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_TWEET_STATS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const statsResp = result.body;
        if (!statsResp) {
            return null
        }
        stateMap.set(cacheKey, statsResp);

        return statsResp;
    },

    // create reply
    async replyTweet({rootId, parentId, parentUserId, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_REPLY,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                root_id: rootId,
                parent_id: parentId,
                user_id: owner.id,
                username: owner.username,
                parent_user_id: parentUserId,
                text: text,
                created_at: new Date().toISOString(),
            },
        }

        const result = await window.go.main.App.Route(request);
        const replyResp = result.body;
        if (!replyResp) {
            return null
        }
        const cacheKey = `reply::${rootId}::${replyResp.id}`;
        stateMap.set(cacheKey, replyResp);
        this.invalidate(`replies::${rootId}`)
        this.invalidate(`tweetstats::${rootId}`)
        return replyResp;
    },

    async getReplies({rootId, parentId, cursorReset}) {
        let cursor = this.getCursor('replies')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const cacheKey = `replies::${rootId}::${parentId}::${defaultLimit}::${cursor}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_GET_REPLIES,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                root_id: rootId,
                parent_id: parentId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const result = await window.go.main.App.Route(request);
        const repliesResp = result.body;
        if (!repliesResp) {
            return []
        }
        this.setCursor('replies', repliesResp.cursor || 'end')
        if (!repliesResp.replies || repliesResp.replies.length === 0) {
            return []
        }
        stateMap.set(cacheKey, repliesResp.replies);
        return repliesResp.replies;
    },

    async getReply({rootId, replyId}) {
        const cacheKey = `reply::${rootId}::${replyId}`;
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()
        const request = {
            path: PUBLIC_GET_REPLY,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                root_id: rootId,
                reply_id: replyId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const replyResp = result.body;
        if (!replyResp) {
            return null
        }
        stateMap.set(cacheKey, replyResp);
        return replyResp;
    },

    async deleteReply({userId, rootId, replyId}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_DELETE_REPLY,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                root_id: rootId,
                reply_id: replyId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const replyResp = result.body;

        const cacheKey = `reply::${rootId}::${replyId}`;
        stateMap.delete(cacheKey);
        this.invalidate(`tweetstats::${rootId}`)
        this.invalidate(`replies::${rootId}`)
        return replyResp;
    },

    async likeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_LIKE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        const likeResp = result.body;

        this.invalidate(`tweetstats::${tweetId}`)
        return likeResp.count;
    },

    async unlikeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNLIKE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.id,
            },
        }

        const result = await window.go.main.App.Route(request);
        const unlikeResp = result.body;

        this.invalidate(`tweetstats::${tweetId}`)
        return unlikeResp.count;
    },

    async setLiker(tweetId, profileId, profileObj) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async retweetTweet({tweetId, userId, username, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_RETWEET,
            node_id:  owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                id: tweetId,
                user_id: userId,
                username: username,
                text: text,
                retweeted_by: owner.id,
                created_at: new Date().toISOString(),
            },
        }

        const result = await window.go.main.App.Route(request);
        const retweetResp = result.body;

        this.invalidate(`timeline`)
        this.invalidate(`tweetstats::${tweetId}`)
        return retweetResp;
    },

    async unretweetTweet(tweetId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNRETWEET,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                retweeter_id: owner.id,
                tweet_id: tweetId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const unretweetResp = result.body;

        this.invalidate(`tweetstats::${tweetId}`)
        return unretweetResp;
    },

    async setRetweeter(tweetId, profileId, profileObj) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async createChat(otherUserId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_CHAT,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                owner_id: owner.id,
                other_user_id: otherUserId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const chatResp = result.body;
        if (!chatResp) {
            return null
        }
        this.invalidate('chats')
        const cacheKey = `chat::${chatResp.id}`
        stateMap.set(cacheKey, chatResp)
        return chatResp;
    },

    async getChat(chatId) {
        const cacheKey = `chat::${chatId}`
        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_GET_CHAT,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                chat_id: chatId,
            },
        }

        const result = await window.go.main.App.Route(request);
        const chatResp = result.body;
        if (!chatResp) {
            return null
        }
        stateMap.set(cacheKey, chatResp)
        return chatResp;
    },

    async getChats(cursorReset) {
        let cursor = this.getCursor('chats')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()
        const cacheKey = `chats::${owner.id}::${defaultLimit}::${cursor}`

        if (stateMap.has(cacheKey)) return stateMap.get(cacheKey);

        const request = {
            path: PRIVATE_GET_CHATS,
                node_id: owner.node_id,
                timestamp: new Date().toISOString(),
                body: {
                user_id: owner.id,
                    limit: defaultLimit,
                    cursor: cursor,
            },
        }

        const result = await window.go.main.App.Route(request);
        const chatsResp = result.body;
        if (!chatsResp) {
            return []
        }
        this.setCursor('chats', chatsResp.cursor || 'end')
        if (!chatsResp.chats || chatsResp.chats.length === 0) {
            return []
        }

        for (const chat of chatsResp.chats) {
            stateMap.set(`chat::${chat.id}`, chat)
        }

        stateMap.set(cacheKey, chatsResp.chats)
        return chatsResp.chats;
    },

    async sendDirectMessage({chatId, receiverId, text}) {
        const owner = this.getOwnerProfile();
        const request = {
            path: PUBLIC_POST_MESSAGE,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                sender_id: owner.id,
                receiver_id: receiverId,
                chat_id: chatId,
                text: text,
            },
        }

        const result =  await window.go.main.App.Route(request);
        return result.body;
    },

    async getDirectMessages({chatId, cursorReset}) {
        let cursor = this.getCursor('messages')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile();

        const cacheKey = `messages::${owner.id}::${defaultLimit}::${cursor}`

        const request = {
            path: PRIVATE_GET_MESSAGES,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                owner_id: owner.id,
                chat_id: chatId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const result = await window.go.main.App.Route(request);
        const messagesResp = result.body;
        if (!messagesResp) {
            return []
        }
        this.setCursor('messages', messagesResp.cursor || 'end')
        if (!messagesResp.messages || messagesResp.messages.length === 0) {
            return []
        }

        stateMap.set(cacheKey, messagesResp.messages)
        return messagesResp.messages;
    },

    async editMyProfile(newProfile) {
        const owner = this.getOwnerProfile();
        const request = {
            path: PRIVATE_POST_USER,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {
                bio: newProfile.bio,
                avatar: newProfile.avatar,
                avatar_key: newProfile.avatar_key,
                username: newProfile.username,
                background_image: newProfile.background_image,
                background_image_key: newProfile.background_image_key,
                website: newProfile.website,
                birthdate: newProfile.birthdate,
            },
        }

        const result = await window.go.main.App.Route(request);
        return result.body;
    },

    async getNodeInfo(){
        const owner = this.getOwnerProfile();
        const request = {
            path: PRIVATE_GET_STATS,
            node_id: owner.node_id,
            timestamp: new Date().toISOString(),
            body: {},
        }

        const result =  await window.go.main.App.Route(request);
        return result.body;
    }
}

// TTL in ms
const ttlMap = {
    'image': 6_000_000,
    'user': 60_000,
    'timeline': 6_000,
    'replies': 6_000,
    'tweetstats': 6_000,
}

function startCacheCleaner() {
    setInterval(() => {
        for (const [prefix, ttl] of Object.entries(ttlMap)) {
            const expirationKey = `${prefix}::expiration`;
            const expiration = stateMap.get(expirationKey) || {createdAt: 0};
            const now = Date.now();

            if (now - expiration.createdAt > ttl) {
                warpnetService.invalidate(prefix);
                stateMap.set(expirationKey, {createdAt: now});
            }
        }
    }, 1000);
}

startCacheCleaner();