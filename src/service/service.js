/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/Warp-net,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

WarpNet is provided “as is” without warranty of any kind, either expressed or implied.
Use at your own risk. The maintainers shall not be liable for any damages or data loss
resulting from the use or misuse of this software.
*/

import {buildQRCode} from "@/lib/qr";
import {generateUUID} from "@/lib/uuid";
import {Call} from "../../wailsjs/go/main/App";

export const PUBLIC_GET_TWEET = "/public/get/tweet/0.0.0"
export const PUBLIC_GET_TWEET_STATS   = "/public/get/tweetstats/0.0.0"
export const PRIVATE_GET_TIMELINE = "/private/get/timeline/0.0.0"
export const PUBLIC_GET_TWEETS = "/public/get/tweets/0.0.0"
export const PRIVATE_GET_NOTIFICATIONS = "/private/get/notifications/0.0.0"
export const PUBLIC_POST_UNLIKE = "/public/post/unlike/0.0.0"
export const PRIVATE_POST_TWEET = "/private/post/tweet/0.0.0"
export const PUBLIC_POST_REPLY = "/public/post/reply/0.0.0"
export const PUBLIC_GET_FOLLOWINGS = "/public/get/followings/0.0.0"
export const PUBLIC_GET_REPLY = "/public/get/reply/0.0.0"
export const PRIVATE_GET_STATS = "/private/get/admin/stats/0.0.0"
export const PUBLIC_DELETE_REPLY = "/public/delete/reply/0.0.0"
export const PRIVATE_DELETE_TWEET = "/private/delete/tweet/0.0.0"
export const PRIVATE_POST_USER = "/private/post/user/0.0.0"
export const PUBLIC_POST_UNFOLLOW = "/public/post/unfollow/0.0.0"
export const PUBLIC_GET_USER = "/public/get/user/0.0.0"
export const PUBLIC_GET_USERS = "/public/get/users/0.0.0"
export const PUBLIC_GET_WHOTOFOLLOW = "/public/get/whotofollow/0.0.0"
export const PUBLIC_GET_REPLIES = "/public/get/replies/0.0.0"
export const PUBLIC_GET_FOLLOWERS = "/public/get/followers/0.0.0"
export const PUBLIC_POST_FOLLOW = "/public/post/follow/0.0.0"
export const PUBLIC_POST_LIKE = "/public/post/like/0.0.0"
export const PUBLIC_POST_RETWEET = "/public/post/retweet/0.0.0"
export const PUBLIC_POST_UNRETWEET = "/public/post/unretweet/0.0.0"
export const PUBLIC_POST_CHAT = "/public/post/chat/0.0.0"
export const PRIVATE_DELETE_CHAT = "/private/delete/chat/0.0.0"
export const PRIVATE_GET_CHATS = "/private/get/chats/0.0.0"
export const PRIVATE_GET_CHAT = "/private/get/chat/0.0.0"
export const PRIVATE_GET_MESSAGES = "/private/get/messages/0.0.0"
export const PUBLIC_POST_MESSAGE = "/public/post/message/0.0.0"
export const PRIVATE_GET_MESSAGE = "/private/get/message/0.0.0"
export const PUBLIC_DELETE_MESSAGE = "/public/delete/message/0.0.0"
export const PRIVATE_POST_UPLOAD_IMAGE = "/private/post/image/0.0.0"
export const PUBLIC_GET_IMAGE = "/public/get/image/0.0.0"
export const PRIVATE_POST_LOGIN = "/private/post/login/0.0.0"

const stateMap = new Map();
const defaultLimit = 20
const endCursor = "end"

export const warpnetService = {
    invalidate(prefix) {
        const keysToDelete = Array.from(stateMap.keys()).filter(k => k.startsWith(prefix));
        for (const key of keysToDelete) {
            stateMap.delete(key);
        }
    },
    setQR(qrData) {
        const key = `QR`;
        stateMap.set(key, qrData)
    },

    getQR() {
        const key = `QR`;
        return stateMap.get(key) || ""
    },

    setCursor(key, cursor) {
        const cacheKey = `${key}::cursor`;
        stateMap.set(cacheKey, cursor)
    },

    getCursor(key) {
        const cacheKey = `${key}::cursor`;
        return stateMap.get(cacheKey) || ""
    },

    setOwnerProfile(owner) {
        const key = `owner`;
        stateMap.set(key, owner)
    },

    getOwnerProfile() {
        const key = `owner`;
        return stateMap.get(key)
    },

    async signInUser(form) {
        let request = {
            path: PRIVATE_POST_LOGIN,
            body: {
                username: form.username,
                password: form.password,
            }
        }
        const resp = await this.sendToNode(request);
        if (!resp || !resp.identity) {
            throw new Error("Login failed: no response")
        }
        if (resp.code) {
            alert(resp.message)
            throw new Error(resp.message)
        }

        if (!resp.identity) {
            throw new Error("Login failed: no identity")
        }

        const qrData = JSON.stringify(resp);
        resp.identity.token = null // for security reasons

        if (!resp.identity.owner) {
            console.error("Login failed: owner identity not received")
            return;
        }

        // type Owner struct {
        // 	CreatedAt time.Time `json:"created_at"`
        // 	NodeId    string    `json:"node_id"`
        // 	UserId    string    `json:"user_id"`
        // 	Username  string    `json:"username"`
        // }

        warpnetService.setOwnerProfile(resp.identity.owner)

        const qrCode = await buildQRCode(qrData)
        warpnetService.setQR(qrCode)
    },

    async getProfile(userId) {
        const request = {
            path: PUBLIC_GET_USER,
            body: {
                user_id: userId,
            },
        }

        return await this.sendToNode(request);
    },

    async getUsers({profileId, cursorReset}) {
        console.log("getUsers", profileId)

        let cursor = this.getCursor('users')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const request = {
            path: PUBLIC_GET_USERS,
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: profileId,
            },
        }

        const usersResp = await this.sendToNode(request);
        if (!usersResp) {
            return []
        }
        this.setCursor('users', usersResp.cursor || "")
        if (!usersResp.users || usersResp.users.length === 0) {
            return []
        }

        usersResp.users = usersResp.users.filter(user => user.id !== profileId);

        return usersResp.users;
    },

    async getWhoToFollow(profileId, cursorReset) {
        let cursor = this.getCursor('whotofollow')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()

        if (!profileId || profileId === '') {
            profileId = owner.user_id
        }

        const request = {
            path: PUBLIC_GET_WHOTOFOLLOW,
            body: {
            limit: defaultLimit,
                cursor: cursor,
                user_id: profileId,
            },
        }

        const followResp = await this.sendToNode(request);
        if (!followResp) {
            return []
        }
        this.setCursor('whotofollow', followResp.cursor || "")

        return followResp.users;
    },

    async uploadImage(imgFile) {
        if (!imgFile) {
            return ''
        }

        const request = {
            path: PRIVATE_POST_UPLOAD_IMAGE,
            timestamp: new Date().toISOString(),
            body: {
                file: imgFile,
            },
        }

        const result = await this.sendToNode(request);
        const hashKey = result.key
        if (!hashKey || hashKey.length === 0) {
            return ''
        }

        return hashKey;
    },

    async getImage({userId, key}) {
        if (!key || key.length === 0) {
            return null
        }

        const request = {
            path: PUBLIC_GET_IMAGE,
            body: {
                user_id: userId,
                key: key,
            }
        }

        const result = await this.sendToNode(request);
        if (!result) {
            return null
        }
        return result.file;
    },

    async getMyTimeline(cursorReset) {
        let cursor = this.getCursor('timeline')
        if (cursorReset) {
            cursor = ''
        }

        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_GET_TIMELINE,
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: owner.user_id,
            },
        }

        const timelineResp = await this.sendToNode(request);
        if (!timelineResp) {
            return []
        }

        this.setCursor('timeline', timelineResp.cursor || 'end')
        if (!timelineResp.tweets || timelineResp.tweets.length === 0) {
            return []
        }

        return timelineResp.tweets;
    },

    async getNotifications({userId,cursorReset}) {
        let cursor = this.getCursor('notifications')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return null
        }

        const request = {
            path: PRIVATE_GET_NOTIFICATIONS,
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: userId,
            },
        }

        const resp = await this.sendToNode(request);
        if (!resp) {
            return null
        }
        this.setCursor('notifications', resp.cursor || 'end')
        return resp;
    },

    async getTweets({userId,cursorReset}) {
        let cursor = this.getCursor('tweets')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const request = {
            path: PUBLIC_GET_TWEETS,
            body: {
                limit: defaultLimit,
                cursor: cursor,
                user_id: userId,
            },
        }

        const tweetsResp = await this.sendToNode(request);
        if (!tweetsResp) {
            return []
        }
        this.setCursor('tweets', tweetsResp.cursor || 'end')
        if (!tweetsResp.tweets || tweetsResp.tweets.length === 0) {
            return []
        }

        return tweetsResp.tweets;
    },

    async createTweet({text, imageKey}) {
        const owner = this.getOwnerProfile()

        const request ={
            path: PRIVATE_POST_TWEET,
            body: {
                user_id: owner.user_id,
                username: owner.username,
                text: text,
                image_key: imageKey,
                created_at: new Date().toISOString(),
            },
        }

        return await this.sendToNode(request);
    },

    async deleteTweet({userId, tweetId}) {
        const request = {
            path: PRIVATE_DELETE_TWEET,
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        return await this.sendToNode(request);
    },

    async getTweet({userId, tweetId}) {
        const request = {
            path: PUBLIC_GET_TWEET,
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        return await this.sendToNode(request);
    },

    async followUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_FOLLOW,
            body: {
                followingId: profileId,
                followerId: owner.user_id,
            },
        }

        return await this.sendToNode(request);
    },

    isFollowed(profileId) {
        // TODO
    },

    isFollower(profileId) {
        // TODO
    },

    async unfollowUser(profileId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNFOLLOW,
            body: {
                followingId: profileId,
                followerId: owner.user_id,
            },
        }

        return await this.sendToNode(request);
    },

    async getFollowers({userId, cursorReset}) {
        let cursor = this.getCursor('followers')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const request = {
            path: PUBLIC_GET_FOLLOWERS,
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const followersResp = await this.sendToNode(request);
        if (!followersResp) {
            return []
        }
        this.setCursor('followers', followersResp.cursor || 'end')
        if (!followersResp.followers || followersResp.followers.length === 0) {
            return []
        }
        followersResp.followers = followersResp.followers.filter(follower => follower !== userId);
        return followersResp.followers;
    },

    async getFollowings({userId, cursorReset}) {
        let cursor = this.getCursor('followings')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const request = {
            path: PUBLIC_GET_FOLLOWINGS,
            body: {
                user_id: userId,
                cursor: cursor,
                limit: defaultLimit,
            },
        }

        const followingsResp = await this.sendToNode(request);
        if (!followingsResp) {
            return []
        }
        this.setCursor('followings', followingsResp.cursor || 'end')
        if (!followingsResp.followings || followingsResp.followings.length === 0) {
            return []
        }
        followingsResp.followings = followingsResp.followings.filter(following => following !== userId);

        return followingsResp.followings;
    },

    async getTweetStats(tweetId, userId) {
        const request = {
            path: PUBLIC_GET_TWEET_STATS,
            body: {
                user_id: userId,
                tweet_id: tweetId,
            },
        }

        return await this.sendToNode(request);
    },

    // create reply
    async replyTweet({rootId, parentId, parentUserId, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_REPLY,
            body: {
                root_id: rootId,
                parent_id: parentId,
                user_id: owner.user_id,
                username: owner.username,
                parent_user_id: parentUserId,
                text: text,
                created_at: new Date().toISOString(),
            },
        }
        return await this.sendToNode(request);
    },

    async getReplies({rootId, parentId, cursorReset}) {
        let cursor = this.getCursor('replies')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const request = {
            path: PUBLIC_GET_REPLIES,
            body: {
                root_id: rootId,
                parent_id: parentId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const repliesResp = await this.sendToNode(request);
        if (!repliesResp) {
            return []
        }
        this.setCursor('replies', repliesResp.cursor || 'end')
        if (!repliesResp.replies || repliesResp.replies.length === 0) {
            return []
        }
        return repliesResp.replies;
    },

    async getReply({rootId, replyId}) {
        const request = {
            path: PUBLIC_GET_REPLY,
            body: {
                root_id: rootId,
                reply_id: replyId,
            },
        }

        return await this.sendToNode(request);
    },

    async deleteReply({userId, rootId, replyId}) {
        const request = {
            path: PUBLIC_DELETE_REPLY,
            body: {
                user_id: userId,
                root_id: rootId,
                reply_id: replyId,
            },
        }

        return await this.sendToNode(request);
    },

    async likeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_LIKE,
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.user_id,
            },
        }

        const likeResp = await this.sendToNode(request);
        return likeResp.count;
    },

    async unlikeTweet(tweetId, userId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNLIKE,
            body: {
                user_id: userId,
                tweet_id: tweetId,
                owner_id: owner.user_id,
            },
        }

        const unlikeResp = await this.sendToNode(request);
        return unlikeResp.count;
    },

    async setLiker(tweetId, profileId, profileObj) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteLiker(tweetId, profileId) {
        const cacheKey = `liker::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async retweetTweet({tweetId, userId, username, text}) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_RETWEET,
            body: {
                id: tweetId,
                user_id: userId,
                username: username,
                text: text,
                retweeted_by: owner.user_id,
                created_at: new Date().toISOString(),
            },
        }

        return await this.sendToNode(request);
    },

    async unretweetTweet(tweetId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_UNRETWEET,
            timestamp: new Date().toISOString(),
            body: {
                retweeter_id: owner.user_id,
                tweet_id: tweetId,
            },
        }

        return await this.sendToNode(request);
    },

    async setRetweeter(tweetId, profileId, profileObj) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.set(cacheKey, profileObj)
    },

    async hasRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.has(cacheKey)
    },

    async getRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        return stateMap.get(cacheKey)
    },

    async deleteRetweeter(tweetId, profileId) {
        const cacheKey = `retweeter::${tweetId}::${profileId}`; // order matters
        stateMap.delete(cacheKey)
    },

    async createChat(otherUserId) {
        const owner = this.getOwnerProfile()

        const request = {
            path: PUBLIC_POST_CHAT,
            body: {
                owner_id: owner.user_id,
                other_user_id: otherUserId,
            },
        }

        return await this.sendToNode(request);
    },

    async getChat(chatId) {
        const request = {
            path: PRIVATE_GET_CHAT,
            body: {
                chat_id: chatId,
            },
        }

        return await this.sendToNode(request);
    },

    async getChats(cursorReset) {
        let cursor = this.getCursor('chats')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile()

        const request = {
            path: PRIVATE_GET_CHATS,
            body: {
                user_id: owner.user_id,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const chatsResp = await this.sendToNode(request);
        if (!chatsResp) {
            return []
        }
        this.setCursor('chats', chatsResp.cursor || 'end')
        if (!chatsResp.chats || chatsResp.chats.length === 0) {
            return []
        }

        return chatsResp.chats;
    },

    async sendDirectMessage({chatId, receiverId, text}) {
        const owner = this.getOwnerProfile();
        const request = {
            path: PUBLIC_POST_MESSAGE,
            body: {
                sender_id: owner.user_id,
                receiver_id: receiverId,
                chat_id: chatId,
                text: text,
            },
        }

        return await this.sendToNode(request);
    },

    async getDirectMessages({chatId, cursorReset}) {
        let cursor = this.getCursor('messages')
        if (cursorReset) {
            cursor = ''
        }
        if (cursor === endCursor) {
            return []
        }

        const owner = this.getOwnerProfile();

        const request = {
            path: PRIVATE_GET_MESSAGES,
            body: {
                owner_id: owner.user_id,
                chat_id: chatId,
                limit: defaultLimit,
                cursor: cursor,
            },
        }

        const messagesResp = await this.sendToNode(request);
        if (!messagesResp) {
            return []
        }
        this.setCursor('messages', messagesResp.cursor || 'end')
        if (!messagesResp.messages || messagesResp.messages.length === 0) {
            return []
        }

        return messagesResp.messages;
    },

    async editMyProfile(newProfile) {
        const request = {
            path: PRIVATE_POST_USER,
            body: {
                bio: newProfile.bio,
                avatar: newProfile.avatar,
                avatar_key: newProfile.avatar_key,
                username: newProfile.username,
                background_image: newProfile.background_image,
                background_image_key: newProfile.background_image_key,
                website: newProfile.website,
                birthdate: newProfile.birthdate,
            },
        }

        return await this.sendToNode(request);
    },

    async getNodeInfo(){
        const request = {
            path: PRIVATE_GET_STATS,
            body: {},
        }

        return await this.sendToNode(request);
    },

    async sendToNode(request) {
        const owner = this.getOwnerProfile()

        request.message_id = generateUUID()
        request.node_id = owner?.node_id || "None"
        request.timestamp = new Date().toISOString()

        const result = await Call(request);
        if (!result) {
            throw new Error(`Unable to send ${request.message_id}`);
        }
        return result.body;
    }
}

function startRefreshNotifications() {
    setInterval(() => {
        try {
            const owner = warpnetService.getOwnerProfile
            warpnetService.getNotifications({userId: owner.user_id, cursorReset: false}).then();
        } catch (err) {
            console.error(`failed to get notifications [${this.user.id}]`, err);
        }
    }, 2000);
}

startRefreshNotifications();